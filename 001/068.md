Formal Vinyl Ostrich

medium

# [M-1] Short-term repeated staking generates more $VVV reward tokens than a continuous 1-year stake

## Summary
**The protocol appears disadvantageous for users with long-term commitment, as they receive a lesser amount of tokens from staking compared to users who engage in short-term repeated staking.**

## Vulnerability Detail
Typically, a staking protocol aims to incentivize users to stake their ether for as long as possible. This is achieved by calibrating rewards (in this case, `$VVV` tokens) such that longer commitments yield greater returns. It's important to note that once ether is staked, it cannot be withdrawn until the staking period has elapsed. However, in this protocol, staking ETH for 1 consecutive year results in less earnings. In fact, it is more profitable to make 4 repeated stakes, each lasting 3 months, rather than a single commitment where the user locks their ether. Similarly, a user engaging in continuous 6-month staking receives fewer `$VVV` reward tokens compared to another user who performs two separate 3-month stakes. Observing [`VVVETHStaking::constructor`](https://github.com/sherlock-audit/2024-03-vvv-vesting-staking/blob/main/vvv-platform-smart-contracts/contracts/staking/VVVETHStaking.sol#L107), it can be noticed that the reward multipliers are set as follows:
```javascript
durationToMultiplier[StakingDuration.ThreeMonths] = 10_000;
durationToMultiplier[StakingDuration.SixMonths] = 15_000;
durationToMultiplier[StakingDuration.OneYear] = 30_000;
```
Indeed, the multiplier is not well proportioned, resulting in unbalanced rewards in favor of a shorter staking duration, particularly the shorter staking period (i.e., `StakingDuration.ThreeMonths`). If repeated multiple times, this yields greater returns compared to a continuous stake of 6 or 12 months.

## Impact
This issue pertains to inconsistency in the staking reward logic and can impact users' perception of the protocol's fairness. Suppose a user strongly believes in the project and wishes to stake their ether for an extended period to receive more advantageous rewards (`$VVV` tokens) compared to short-term commitment users. In this scenario, short-term users would unfairly be rewarded more than the loyal user, impacting the protocol's fairness towards users.\
Lastly, it's important to note that the gained advantage grows linearly: this means that the greater the amount of ETH staked, the larger the gap between the rewards generated by the 12-month stake and the rewards generated by the 3-month stake (repeated 4 times). The linear growth factor can be derived from the formula used for calculating [`VVVETHStaking::nominalAccruedEth`](https://github.com/sherlock-audit/2024-03-vvv-vesting-staking/blob/main/vvv-platform-smart-contracts/contracts/staking/VVVETHStaking.sol#L234):
```javascript
uint256 nominalAccruedEth = (secondsStaked * _stake.stakedEthAmount) / stakeDuration;
```

## Code Snippet

https://github.com/sherlock-audit/2024-03-vvv-vesting-staking/blob/main/vvv-platform-smart-contracts/contracts/staking/VVVETHStaking.sol#L114-L116

**Proof of Concept:** the aim is to demonstrate that a loyal user who stakes their ether, keeping it locked for a long period of time (1 year), receives less compensation compared to a user who is aware of this logic inconsistency in the protocol, and engages in repeated shorter-duration staking. The steps for the demonstration are as follows:

1. The loyal user (let's call her Alice) stakes a certain amount of ether for 1 year. The amount of ether is not important, but it is crucial to consider that the disadvantage of the 1-year stake increases with the amount of ETH staked.
2. The user who is aware of this protocol inconsistency (let's call him Bob) initiates a 3-month ETH stake, with the intention of renewing it upon expiration.
3. At the end of the 3-month stake period, Bob restakes his ETH using the [`VVVETHStaking::restake`](https://github.com/sherlock-audit/2024-03-vvv-vesting-staking/blob/main/vvv-platform-smart-contracts/contracts/staking/VVVETHStaking.sol#L147) function.
    1. At the 6th month, Bob's second stake expires, and he repeats the procedure by restaking it using the `VVVETHStaking::restake` method.
    2. At the 9th month, Bob repeats the procedure.
4. Upon reaching the 12th month, both Alice's stake (continuous for 12 months) and Bob's fourth 3-month stake expire.
5. At this point, we can use the [`VVVETHStaking::accruedVvv`](https://github.com/sherlock-audit/2024-03-vvv-vesting-staking/blob/main/vvv-platform-smart-contracts/contracts/staking/VVVETHStaking.sol#L236) formula to calculate the accrued reward tokens for Alice and Bob over these 12 months, observing that the `$VVV` tokens generated by Alice are less than those of Bob, with a linear growth factor. This implies, as previously mentioned, the greater the amount of Ether staked by Alice, the more disadvantageous it is for her to maintain a continuous 12-month commitment.

**Proof of Code:** The following code provides a formal verification of Alice's disadvantage in staking her ether for 12 consecutive months. This unit test should be added to the end of the [`VVVETHStaking.unit.t.sol`](https://github.com/sherlock-audit/2024-03-vvv-vesting-staking/blob/main/vvv-platform-smart-contracts/test/staking/VVVETHStaking.unit.t.sol) file, then run the command `forge test --mt testLongTermStakingWorseThanShortTerm -vvv` to execute the test. If there are issues with `console.log`, it is advisable to verify that the `forge-std` directory is correctly configured within the [`remappings.txt`](https://github.com/sherlock-audit/2024-03-vvv-vesting-staking/blob/main/vvv-platform-smart-contracts/remappings.txt) file. Alternatively, you can comment out the lines containing `console.log` within the test.

<details>

<summary>Code</summary>

```javascript
  function testLongTermStakingWorseThanShortTerm() public {
        vm.startPrank(sampleUser, sampleUser);
        uint256 stakeDuration = 90 days;
        uint256 stakeEthAmount = 10 ether;
        uint256 secondsStaked = EthStakingInstance.durationToSeconds(VVVETHStaking.StakingDuration.ThreeMonths);
        uint256 nominalAccruedEth = (secondsStaked * stakeEthAmount) / stakeDuration;
        uint256 accruedVvvRepeatedStakes = (nominalAccruedEth * EthStakingInstance.ethToVvvExchangeRate() *
            EthStakingInstance.durationToMultiplier(VVVETHStaking.StakingDuration.ThreeMonths)) / EthStakingInstance.DENOMINATOR();

        uint256 stakeId = EthStakingInstance.stakeEth{ value: stakeEthAmount }(
            VVVETHStaking.StakingDuration.ThreeMonths
        );

        // forward to first timestamp with released stake
        advanceBlockNumberAndTimestampInSeconds(
            EthStakingInstance.durationToSeconds(VVVETHStaking.StakingDuration.ThreeMonths) + 1
        );

        // restake another 3 times to compare with a single 1 year stake
        for (uint256 i = 0; i < 3; i++) {
            stakeId = EthStakingInstance.restakeEth(stakeId, VVVETHStaking.StakingDuration.ThreeMonths);
            accruedVvvRepeatedStakes += (nominalAccruedEth * EthStakingInstance.ethToVvvExchangeRate() *
                EthStakingInstance.durationToMultiplier(VVVETHStaking.StakingDuration.ThreeMonths)) / EthStakingInstance.DENOMINATOR();

            // jump to end of stake duration
            advanceBlockNumberAndTimestampInSeconds(
                EthStakingInstance.durationToSeconds(VVVETHStaking.StakingDuration.ThreeMonths) + 1
            );
        }
        vm.stopPrank();

        /* -----------------------------------------
        --- repeating with a single 1 year stake ---
        ------------------------------------------ */

        uint256 accruedVvvSingleStake;
        address newUser = makeAddr("user");
        stakeDuration = 360 days;
        vm.deal(newUser, 10 ether);

        vm.startPrank(newUser, newUser);
        secondsStaked = EthStakingInstance.durationToSeconds(VVVETHStaking.StakingDuration.OneYear);
        // using the same ETH amount to stake, for a fair comparison
        stakeId = EthStakingInstance.stakeEth{ value: stakeEthAmount }(
            VVVETHStaking.StakingDuration.OneYear
        );

        nominalAccruedEth = (secondsStaked * stakeEthAmount) / stakeDuration;
        accruedVvvSingleStake = (nominalAccruedEth * EthStakingInstance.ethToVvvExchangeRate() *
            EthStakingInstance.durationToMultiplier(VVVETHStaking.StakingDuration.OneYear)) / EthStakingInstance.DENOMINATOR();

        advanceBlockNumberAndTimestampInSeconds(
            EthStakingInstance.durationToSeconds(VVVETHStaking.StakingDuration.OneYear) + 1
        );
        vm.stopPrank();

        console.log("Reward tokens generated from repeated 3-month stakes: ", accruedVvvRepeatedStakes);
        console.log("Reward tokens generated from a continuous 1 year commitment: ", accruedVvvSingleStake);
        vm.expectRevert();
        assert(accruedVvvRepeatedStakes <= accruedVvvSingleStake);

    }
```

</details>

## Tool used

The inconsistency in reward weights was observed through manual review, followed by a formal demonstration by writing a custom test with [Foundry](https://book.getfoundry.sh).

## Recommendation
To ensure fairness in the staking reward mechanism, it is recommended to make at least one of the following two changes:
1. During the initialization of the [`VVVETHStaking.sol`](https://github.com/sherlock-audit/2024-03-vvv-vesting-staking/blob/main/vvv-platform-smart-contracts/contracts/staking/VVVETHStaking.sol) contract, the constructor can be modified to set multipliers that are fairer to users. If balanced multipliers between various staking durations are desired, with no incentive for long-term commitment, the constructor should be defined as follows:
```diff
constructor(
        address _authorizationRegistryAddress
    ) VVVAuthorizationRegistryChecker(_authorizationRegistryAddress) {
        durationToSeconds[StakingDuration.ThreeMonths] = 90 days;
        durationToSeconds[StakingDuration.SixMonths] = 180 days;
        durationToSeconds[StakingDuration.OneYear] = 360 days;

-       durationToMultiplier[StakingDuration.ThreeMonths] = 10_000;
+       durationToMultiplier[StakingDuration.ThreeMonths] = 7_500;
        durationToMultiplier[StakingDuration.SixMonths] = 15_000;
        durationToMultiplier[StakingDuration.OneYear] = 30_000;
    }
```
However, if the goal is to incentivize users to hold their tokens in stake for a longer period, it is recommended to ensure that the multiplier becomes increasingly advantageous with the duration of staking. An example could be as follows:
```diff
constructor(
        address _authorizationRegistryAddress
    ) VVVAuthorizationRegistryChecker(_authorizationRegistryAddress) {
        durationToSeconds[StakingDuration.ThreeMonths] = 90 days;
        durationToSeconds[StakingDuration.SixMonths] = 180 days;
        durationToSeconds[StakingDuration.OneYear] = 360 days;

-       durationToMultiplier[StakingDuration.ThreeMonths] = 10_000;
-       durationToMultiplier[StakingDuration.SixMonths] = 15_000;
-       durationToMultiplier[StakingDuration.OneYear] = 30_000;

+       durationToMultiplier[StakingDuration.ThreeMonths] = 9_000;
+       durationToMultiplier[StakingDuration.SixMonths] = 20_000;
+       durationToMultiplier[StakingDuration.OneYear] = 50_000;
    }
```
2. Another possible approach is to use the [`VVVETHStaking::setDurationMultipliers`](https://github.com/sherlock-audit/2024-03-vvv-vesting-staking/blob/main/vvv-platform-smart-contracts/contracts/staking/VVVETHStaking.sol#L264C14-L264C36) function to modify the multiplier values and assign balanced values that are fair to users. For example, following the concept shown in point 1 to incentivize users to hold their ETH in stake for a long period, you could call the `setDurationMultipliers` function by assigning the multiplier values shown in point 1.